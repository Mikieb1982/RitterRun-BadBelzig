<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>RitterRun Enhanced - Bad Belzig (Mouse Click Jump)</title> <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        /* All CSS remains the same */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { width: 100%; height: 100%; overflow: hidden; background-color: #222; }
        :root { --bb-green: #0ca644; --bb-blue: #0296c6; --bb-yellow: #f5d306; --bb-black: #151513; --bb-white: #ffffff; --font-pixel: 'Press Start 2P', cursive; --font-sans: 'Arial', sans-serif; }
        body { display: flex; justify-content: center; align-items: center; margin: 0; font-family: var(--font-sans); }
        #game-container { position: relative; border: 3px solid #555; overflow: hidden; background-color: var(--bb-blue); width: 800px; height: 400px; max-width: 100%; box-sizing: border-box; display: block; }
        @media (max-width: 850px) { #game-container { width: 100vw; height: 50vw; max-height: 100vh; max-width: 200vh; max-width: 100vw; } #scoreDisplay, #livesDisplay { font-size: 1.2em; } .poi-overlay h3 { font-size: 1em; } .poi-overlay p { font-size: 0.8em; } #closePoiButton { font-size: 0.8em; } }
        canvas { display: block; width: 100%; height: 100%; }
        #knightImage { position: absolute; display: none; pointer-events: none; z-index: 10; image-rendering: pixelated; }
        .ui-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.8); color: var(--bb-white); display: flex; flex-direction: column; justify-content: center; align-items: center; text-align: center; z-index: 30; padding: 20px; font-family: var(--font-pixel); line-height: 1.6; }
        .ui-screen h1 { font-size: 2.5em; margin-bottom: 20px; color: var(--bb-yellow); text-shadow: 3px 3px 0px var(--bb-black); }
        .ui-screen h2 { font-size: 2.2em; margin-bottom: 20px; color: #DC143C; text-shadow: 3px 3px 0px var(--bb-black); }
        .ui-screen p { font-size: 1em; margin: 10px 0; }
        .ui-button { padding: 15px 30px; font-size: 1.1em; font-family: var(--font-pixel); margin-top: 30px; cursor: pointer; background-color: #eee; border: 3px solid var(--bb-black); color: var(--bb-black); text-transform: uppercase; transition: background-color 0.15s ease, transform 0.1s ease; box-shadow: 4px 4px 0px var(--bb-black); }
        .ui-button:hover { background-color: #ddd; }
        .ui-button:active { background-color: #ccc; transform: translate(2px, 2px); box-shadow: 2px 2px 0px var(--bb-black); }
        .instructions { margin-top: 25px; font-size: 0.8em !important; color: #ccc; line-height: 1.5; }
        #scoreDisplay, #livesDisplay { position: absolute; top: 15px; font-size: 1.5em; font-family: var(--font-pixel); color: var(--bb-white); text-shadow: 2px 2px 0px var(--bb-black); z-index: 20; }
        #scoreDisplay { left: 15px; }
        #livesDisplay { right: 15px; }
        .poi-overlay { position: absolute; top: 20px; left: 50%; transform: translateX(-50%); width: 90%; max-width: 600px; background-color: rgba(0, 0, 0, 0.85); border: 3px solid var(--bb-yellow); border-radius: 0; z-index: 50; color: var(--bb-white); padding: 15px 20px; text-align: center; font-family: var(--font-pixel); box-shadow: 4px 4px 0px rgba(0,0,0,0.5); display: none; cursor: pointer; }
        .poi-overlay.visible { display: block !important; }
        .poi-overlay h3 { margin-bottom: 10px; font-size: 1.1em; color: var(--bb-yellow); text-shadow: 2px 2px 0px var(--bb-black); }
        .poi-overlay p { font-size: 0.9em; line-height: 1.6; color: var(--bb-white); margin-bottom: 15px; }
        #closePoiButton { padding: 8px 15px; font-size: 0.9em; font-family: var(--font-pixel); cursor: pointer; background-color: #ccc; border: 2px solid var(--bb-black); color: var(--bb-black); margin-top: 10px; box-shadow: 2px 2px 0px var(--bb-black); }
        #closePoiButton:hover { background-color: #bbb; }
        #closePoiButton:active { background-color: #aaa; transform: translate(1px, 1px); box-shadow: 1px 1px 0px var(--bb-black); }
        .hidden { display: none !important; }
        #orientationMessage { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: var(--bb-black); color: var(--bb-white); display: flex; flex-direction: column; justify-content: center; align-items: center; text-align: center; z-index: 100; font-family: var(--font-pixel); padding: 20px; line-height: 1.8; font-size: 1.2em; display: none; }
        #orientationMessage p { margin-bottom: 1em; }
        @media (orientation: portrait) { #game-container { display: none; } #orientationMessage { display: flex; } }
        @media (orientation: landscape) { #orientationMessage { display: none; } }
    </style>
</head>
<body>
    <div id="orientationMessage">
        <p>Please rotate your device to landscape mode to play.</p>
        <p>Bitte drehe dein Gerät ins Querformat, um zu spielen.</p>
    </div>

    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        <img id="knightImage" src="" alt="Knight">
        <div id="poiInfoOverlay" class="poi-overlay">
            <h3 id="poiName">POI Name</h3>
            <p id="poiInfoText">POI information will appear here.</p>
            <button id="closePoiButton">Close</button>
        </div>
        <div id="startScreen" class="ui-screen">
            <h1>RitterRun</h1>
            <p>Explore Bad Belzig!</p>
            <p>High Score: <span id="startHighScore">0</span></p>
            <button id="startButton" class="ui-button">Start Game</button>
            <p class="instructions">Press SPACE or Click Start<br>Press SPACE to Jump</p>
        </div>
        <div id="gameOverScreen" class="ui-screen hidden">
            <h2>Game Over!</h2>
            <p>Score: <span id="finalScore">0</span></p>
            <p>High Score: <span id="gameOverHighScore">0</span></p>
            <button id="restartButton" class="ui-button">Restart</button>
        </div>
        <div id="scoreDisplay" class="hidden">Score: <span id="currentScore">0</span></div>
        <div id="livesDisplay" class="hidden">Lives: <span id="currentLives">5</span></div>
    </div>

    <script>
        // --- Strict mode and IIFE ---
        (function() {
            'use strict';

            // --- DOM Element References ---
            const canvas = document.getElementById('gameCanvas');
            const gameContainer = document.getElementById('game-container');
            // ... (other refs remain the same) ...
            const startScreen = document.getElementById('startScreen');
            const gameOverScreen = document.getElementById('gameOverScreen');
            const startButton = document.getElementById('startButton');
            const restartButton = document.getElementById('restartButton');
            const scoreDisplay = document.getElementById('scoreDisplay');
            const currentScoreSpan = document.getElementById('currentScore');
            const finalScoreSpan = document.getElementById('finalScore');
            const startHighScoreSpan = document.getElementById('startHighScore');
            const gameOverHighScoreSpan = document.getElementById('gameOverHighScore');
            const poiOverlay = document.getElementById('poiInfoOverlay');
            const poiNameEl = document.getElementById('poiName');
            const poiInfoTextEl = document.getElementById('poiInfoText');
            const closePoiButton = document.getElementById('closePoiButton');
            const livesDisplay = document.getElementById('livesDisplay');
            const currentLivesSpan = document.getElementById('currentLives');
            const knightImageEl = document.getElementById('knightImage');


            // --- Canvas and Context ---
            let ctx;
            let canvasWidth;
            let canvasHeight;

            // --- Essential Element Check ---
            if (!canvas || !canvas.getContext || !gameContainer) { /* ... */ return; }
            ctx = canvas.getContext('2d');
            const requiredElements = { startScreen, gameOverScreen, startButton, restartButton, scoreDisplay, currentScoreSpan, finalScoreSpan, startHighScoreSpan, gameOverHighScoreSpan, poiOverlay, poiNameEl, poiInfoTextEl, closePoiButton, livesDisplay, currentLivesSpan, knightImageEl };
            for (const key in requiredElements) { if (!requiredElements[key]) { console.error(`Fatal Error: UI element '${key}' not found!`); alert(`Fatal Error: UI element missing (${key})!`); return; } }

            // --- Game States ---
            const GameState = Object.freeze({ MENU: 'MENU', PLAYING: 'PLAYING', GAME_OVER: 'GAME_OVER', LOADING: 'LOADING' });
            let currentGameState = GameState.LOADING;

            // --- Collision Types ---
            const CollisionType = Object.freeze({ NONE: 0, TOP: 1, SIDE: 2 });

            // --- Game Constants ---
            const LIVES_START_COUNT = 5;
            const INVINCIBILITY_DURATION_MS = 1000;
            const GROUND_HEIGHT_PERCENT = 0.075;
            const PLAYER_INITIAL_X_PERCENT = 0.075;
            const PLAYER_WIDTH_PERCENT_DESKTOP = 0.05;
            const PLAYER_HEIGHT_PERCENT_DESKTOP = 0.10;
            const PLAYER_WIDTH_PERCENT_MOBILE = 0.07;
            const PLAYER_HEIGHT_PERCENT_MOBILE = 0.14;
            const PLAYER_GRAVITY_FACTOR = 1300;
            const PLAYER_JUMP_FACTOR = -40;
            const PLAYER_BOUNCE_POWER_MULTIPLIER = 0.8;
            const OBSTACLE_STONE_WIDTH_PERCENT = 0.044;
            const OBSTACLE_STONE_HEIGHT_PERCENT = 0.088;
            const OBSTACLE_TRACTOR_WIDTH_PERCENT = 0.088;
            const OBSTACLE_TRACTOR_HEIGHT_PERCENT = 0.113;
            const POI_SIGN_WIDTH_PERCENT = 0.113;
            const POI_SIGN_HEIGHT_PERCENT = 0.275;
            const INITIAL_GAME_SPEED_FACTOR = 0.375;
            const SPEED_INCREASE_INTERVAL_SCORE = 400;
            const SPEED_INCREASE_AMOUNT_FACTOR = 0.025;
            const BACKGROUND_SWITCH_SCORE_INTERVAL = 1000;
            const POI_SPAWN_CHANCE = 0.15;
            const OBSTACLE_BASE_SPAWN_TIME_MS = 1800;
            const OBSTACLE_MIN_SPAWN_TIME_MS = 800;
            const COLLISION_LANDING_TOLERANCE_FACTOR = 0.045;
            const MOBILE_BREAKPOINT_WIDTH = 850;

            // --- Game Variables ---
            let score = 0; let highScore = 0; let playerLives = LIVES_START_COUNT; let playerInvincibleUntil = 0;
            let player = { x: 0, y: 0, width: 0, height: 0, dx: 0, dy: 0, gravity: 0, jumpPower: 0, grounded: true };
            let obstacles = []; let gameSpeed = 0; let nextSpeedIncreaseScore = SPEED_INCREASE_INTERVAL_SCORE;
            let bgX = 0; let currentBackgroundIndex = 0; let nextBackgroundSwitchScore = BACKGROUND_SWITCH_SCORE_INTERVAL;
            let nextObstacleSpawnTime = 0; let nextPoiIndex = 0; let lastTime = 0;
            let gameInitialized = false; let isPaused = false; let groundHeightPx = 0; let collisionLandingTolerancePx = 0;
            let currentKnightVisualState = null;

            // --- Graphics Assets ---
            const assets = { /* ... */ knight_run: { img: new Image(), loaded: false, src: 'assets/knight_run.gif' }, knight_jump: { img: new Image(), loaded: false, src: 'assets/knight_jump.png' }, stone: { img: new Image(), loaded: false, src: 'assets/stone.png' }, sign: { img: new Image(), loaded: false, src: 'assets/sign.png' }, tractor: { img: new Image(), loaded: false, src: 'assets/tractor.png' }, background1: { img: new Image(), loaded: false, src: 'assets/background1.png' }, background2: { img: new Image(), loaded: false, src: 'assets/background2.png' }, background3: { img: new Image(), loaded: false, src: 'assets/background3.png' } };
            const numBackgrounds = 3;
            let assetsLoadedCount = 0; let totalAssets = Object.keys(assets).length; let allAssetsLoaded = false;

            // --- Obstacle/POI Definitions ---
            const regularObstacleTypes = [ /* ... */ { assetKey: 'stone', widthPercent: OBSTACLE_STONE_WIDTH_PERCENT, heightPercent: OBSTACLE_STONE_HEIGHT_PERCENT }, { assetKey: 'tractor', widthPercent: OBSTACLE_TRACTOR_WIDTH_PERCENT, heightPercent: OBSTACLE_TRACTOR_HEIGHT_PERCENT } ];
            const poiSignDimensions = { widthPercent: POI_SIGN_WIDTH_PERCENT, heightPercent: POI_SIGN_HEIGHT_PERCENT };

            // --- POI Data Structure ---
            const poiData = [ /* ... */ { id: 1, name: "SteinTherme", info: "Known for its unique thermal saltwater pools and health benefits. | Bekannt für ihre einzigartigen Thermalsolebecken und Gesundheitsvorteile." }, { id: 2, name: "Freibad", info: "The popular outdoor swimming pool, perfect for summer days. | Das beliebte Freibad, perfekt für Sommertage." }, { id: 3, name: "Kulturzentrum & Bibliothek", info: "A cultural hub with its distinctive red-brick facade and arched windows. | Ein kultureller Mittelpunkt mit markanter roter Backsteinfassade und Bogenfenstern." }, { id: 4, name: "Fläming Bahnhof", info: "The local train station connecting Bad Belzig to the region. | Der lokale Bahnhof, der Bad Belzig mit der Region verbindet." }, { id: 5, name: "Postmeilensäule", info: "A historic post mile marker showing distances on old postal routes. | Ein historischer Postmeilenstein, der Entfernungen auf alten Postrouten anzeigt." }, { id: 6, name: "Rathaus & Tourist-Information", info: "The town hall, center of local government and visitor information. | Rathaus, Zentrum der Kommunalverwaltung und Besucherinformation." }, { id: 7, name: "Burg Eisenhardt", info: "Well-preserved medieval castle, vital to the region's history and defense. | Gut erhaltene mittelalterliche Burg, entscheidend für die Geschichte und Verteidigung der Region." } ];

            // --- Asset Loading Functions ---
            function assetLoaded(assetKey) { /* ... */ console.log(`Asset loaded: ${assetKey}`); assets[assetKey].loaded = true; assetsLoadedCount++; if (assetsLoadedCount === totalAssets) { console.log("All assets loaded."); allAssetsLoaded = true; if (currentGameState === GameState.LOADING) { initGame(); } } }
            function assetLoadError(assetKey) { /* ... */ console.error(`Failed to load asset: ${assets[assetKey].src}. Check path and file existence.`); alert(`Error loading image: ${assets[assetKey].src}\nGame might not display correctly.`); assetsLoadedCount++; if (assetsLoadedCount === totalAssets) { allAssetsLoaded = true; if (currentGameState === GameState.LOADING) { initGame(); } } }
            function loadAssets() { /* ... */ console.log("Starting asset loading..."); currentGameState = GameState.LOADING; for (const key in assets) { if (Object.prototype.hasOwnProperty.call(assets, key) && assets[key].img) { assets[key].img.src = assets[key].src; assets[key].img.onload = () => assetLoaded(key); assets[key].img.onerror = () => assetLoadError(key); } } }

            // --- High Score Handling ---
            function loadHighScore() { /* ... */ try { const savedScore = localStorage.getItem('ritterRunHighScore'); highScore = savedScore ? parseInt(savedScore, 10) : 0; if (isNaN(highScore)) highScore = 0; startHighScoreSpan.textContent = highScore; gameOverHighScoreSpan.textContent = highScore; } catch (e) { console.error("LS Error Load HS:", e); highScore = 0; } }
            function saveHighScore() { /* ... */ if (score > highScore) { highScore = score; try { localStorage.setItem('ritterRunHighScore', highScore.toString()); gameOverHighScoreSpan.textContent = highScore; } catch (e) { console.error("LS Error Save HS:", e); } } }

            // --- Sound Playing Helper (Stub) ---
            function playSound(soundId) { console.log(`Playing sound: ${soundId}`); }

            // --- Reset Game Variables ---
            function resetGame() { /* ... */
                score = 0; playerLives = LIVES_START_COUNT; playerInvincibleUntil = 0; obstacles = [];
                groundHeightPx = canvasHeight * GROUND_HEIGHT_PERCENT; collisionLandingTolerancePx = canvasHeight * COLLISION_LANDING_TOLERANCE_FACTOR; gameSpeed = canvasWidth * INITIAL_GAME_SPEED_FACTOR;
                player.gravity = canvasHeight / PLAYER_GRAVITY_FACTOR; player.jumpPower = canvasHeight / PLAYER_JUMP_FACTOR;
                const isMobile = window.innerWidth <= MOBILE_BREAKPOINT_WIDTH;
                console.log(`isMobile check (width <= ${MOBILE_BREAKPOINT_WIDTH}): ${isMobile}`);
                if (isMobile) { player.width = canvasWidth * PLAYER_WIDTH_PERCENT_MOBILE; player.height = canvasHeight * PLAYER_HEIGHT_PERCENT_MOBILE; }
                else { player.width = canvasWidth * PLAYER_WIDTH_PERCENT_DESKTOP; player.height = canvasHeight * PLAYER_HEIGHT_PERCENT_DESKTOP; }
                player.x = canvasWidth * PLAYER_INITIAL_X_PERCENT; player.y = canvasHeight - groundHeightPx - player.height; player.dy = 0; player.grounded = true;
                nextSpeedIncreaseScore = SPEED_INCREASE_INTERVAL_SCORE; bgX = 0; currentBackgroundIndex = 0; nextBackgroundSwitchScore = BACKGROUND_SWITCH_SCORE_INTERVAL;
                currentScoreSpan.textContent = score; currentLivesSpan.textContent = playerLives; nextObstacleSpawnTime = 0; nextPoiIndex = 0; isPaused = false;
                poiOverlay.classList.remove('visible'); knightImageEl.style.display = 'none'; currentKnightVisualState = null;
                console.log(`Game Reset - Speed: ${gameSpeed.toFixed(1)}, Player Size: ${player.width.toFixed(0)}x${player.height.toFixed(0)}, Gravity: ${player.gravity.toFixed(2)}, Jump: ${player.jumpPower.toFixed(1)}`);
            }

            // --- Update Functions ---
            function updatePlayer(dt) { /* ... */ if (!player.grounded) { player.dy += player.gravity; player.y += player.dy * dt * 60; } const groundLevel = canvasHeight - groundHeightPx - player.height; if (player.y >= groundLevel) { player.y = groundLevel; player.dy = 0; if (!player.grounded) { player.grounded = true; } } }
            function updateObstacles(dt, currentTime) { /* ... */
                 if (currentTime >= nextObstacleSpawnTime) { /* ... spawning logic ... */
                    let newObjectData = null; const willSpawnPOI = Math.random() < POI_SPAWN_CHANCE; const canSpawnPOI = nextPoiIndex < poiData.length && assets.sign.loaded; const spawnPOI = willSpawnPOI && canSpawnPOI;
                    if (spawnPOI) { const poi = poiData[nextPoiIndex]; const objWidth = canvasWidth * poiSignDimensions.widthPercent; const objHeight = canvasHeight * poiSignDimensions.heightPercent; newObjectData = { isPOI: true, poiId: poi.id, passed: false, x: canvasWidth, y: canvasHeight - groundHeightPx - objHeight, width: objWidth, height: objHeight, assetKey: 'sign' }; nextPoiIndex++; }
                    else { if (regularObstacleTypes.length > 0) { const typeIndex = Math.floor(Math.random() * regularObstacleTypes.length); const type = regularObstacleTypes[typeIndex]; if (assets[type.assetKey] && assets[type.assetKey].loaded) { const objWidth = canvasWidth * type.widthPercent; const objHeight = canvasHeight * type.heightPercent; newObjectData = { isPOI: false, x: canvasWidth, y: canvasHeight - groundHeightPx - objHeight, width: objWidth, height: objHeight, assetKey: type.assetKey, isKnocked: false }; } } }
                    if (newObjectData) { obstacles.push(newObjectData); }
                    const speedFactor = gameSpeed / (canvasWidth * INITIAL_GAME_SPEED_FACTOR); const currentSpawnTime = OBSTACLE_BASE_SPAWN_TIME_MS / Math.max(1, speedFactor); const nextSpawnDelay = Math.max(OBSTACLE_MIN_SPAWN_TIME_MS, currentSpawnTime) + (Math.random() * 300 - 150); nextObstacleSpawnTime = currentTime + nextSpawnDelay;
                 }
                 const movement = gameSpeed * dt;
                 for (let i = obstacles.length - 1; i >= 0; i--) { /* ... movement, POI trigger, removal ... */
                    const obj = obstacles[i]; if (obj.isKnocked) { obj.y += (canvasHeight * 1.25) * dt; } else { obj.x -= movement; }
                    if (obj.isPOI && !obj.passed) { const triggerPoint = obj.x; const playerRightEdge = player.x + player.width; if (playerRightEdge > triggerPoint) { console.log(`>>> POI TRIGGERED! ID: ${obj.poiId}`); displayPOIInfo(obj.poiId); obj.passed = true; score += 50; currentScoreSpan.textContent = score; playSound('poi'); } }
                    if (obj.x + obj.width < -100 || obj.y > canvasHeight + obj.height + 50) { obstacles.splice(i, 1); }
                 }
             }
            function checkCollisions() { /* ... */ const now = performance.now(); if (now < playerInvincibleUntil) { return { type: CollisionType.NONE }; } const playerRect = { x: player.x + (player.width * 0.1), y: player.y + (player.height * 0.1), width: player.width * 0.8, height: player.height * 0.8, bottom: player.y + player.height, right: player.x + player.width }; for (const obstacle of obstacles) { if (obstacle.isPOI || obstacle.isKnocked) { continue; } const obstacleRect = { x: obstacle.x, y: obstacle.y, width: obstacle.width, height: obstacle.height, top: obstacle.y, right: obstacle.x + obstacle.width }; if (playerRect.x < obstacleRect.right && playerRect.right > obstacleRect.x && playerRect.y < obstacleRect.y + obstacleRect.height && playerRect.bottom > obstacleRect.top) { const isFalling = player.dy >= 0; const landedOnTop = playerRect.bottom >= obstacleRect.top && playerRect.bottom <= obstacleRect.top + collisionLandingTolerancePx; if (isFalling && landedOnTop) { console.log(`Collision: TOP on ${obstacle.assetKey}`); return { type: CollisionType.TOP, obstacle: obstacle }; } console.warn(`Collision: SIDE with ${obstacle.assetKey}`); return { type: CollisionType.SIDE }; } } return { type: CollisionType.NONE }; }
            function updateScoreAndSpeed() { /* ... */ score++; currentScoreSpan.textContent = score; if (score >= nextSpeedIncreaseScore) { gameSpeed += canvasWidth * SPEED_INCREASE_AMOUNT_FACTOR; nextSpeedIncreaseScore += SPEED_INCREASE_INTERVAL_SCORE; console.log(`Speed increased to: ${gameSpeed.toFixed(1)}`); } if (score >= nextBackgroundSwitchScore) { currentBackgroundIndex = (currentBackgroundIndex + 1) % numBackgrounds; nextBackgroundSwitchScore += BACKGROUND_SWITCH_SCORE_INTERVAL; console.log(`Background switched to index: ${currentBackgroundIndex}`); } }

            // --- Draw Functions ---
            function drawBackground(dt) { /* ... */ const currentBgIndex = currentBackgroundIndex + 1; const currentAssetKey = `background${currentBgIndex}`; const currentAsset = assets[currentAssetKey]; const bgMovement = isPaused ? 0 : (gameSpeed / 2) * dt; bgX -= bgMovement; if (bgX <= -canvasWidth) { bgX += canvasWidth; } if (currentAsset && currentAsset.loaded) { ctx.drawImage(currentAsset.img, bgX, 0, canvasWidth, canvasHeight); ctx.drawImage(currentAsset.img, bgX + canvasWidth, 0, canvasWidth, canvasHeight); } else { ctx.fillStyle = '#87CEEB'; ctx.fillRect(0, 0, canvasWidth, canvasHeight); } ctx.fillStyle = '#228B22'; ctx.fillRect(0, canvasHeight - groundHeightPx, canvasWidth, groundHeightPx); }
            function drawObstacles() { /* ... */ for (const obj of obstacles) { if (assets[obj.assetKey] && assets[obj.assetKey].loaded) { ctx.drawImage(assets[obj.assetKey].img, obj.x, obj.y, obj.width, obj.height); } else { ctx.fillStyle = obj.isPOI ? 'blue' : 'red'; ctx.fillRect(obj.x, obj.y, obj.width, obj.height); } } }
            function updateKnightVisuals() { /* ... */ const now = performance.now(); let targetState = player.grounded ? 'run' : 'jump'; let targetSrc = player.grounded ? assets.knight_run.src : assets.knight_jump.src; if (targetState !== currentKnightVisualState || !knightImageEl.src) { if ((targetState === 'run' && assets.knight_run.loaded) || (targetState === 'jump' && assets.knight_jump.loaded)) { if (knightImageEl.src !== targetSrc) { knightImageEl.src = targetSrc; console.log(`Set knight visual state to: ${targetState}`); } currentKnightVisualState = targetState; } } let currentOpacity = 1; if (now < playerInvincibleUntil) { if (Math.floor(now / 100) % 2 !== 0) { currentOpacity = 0.4; } } knightImageEl.style.opacity = currentOpacity; knightImageEl.style.left = `${player.x}px`; knightImageEl.style.top = `${player.y}px`; knightImageEl.style.width = `${player.width}px`; knightImageEl.style.height = `${player.height}px`; if (currentGameState === GameState.PLAYING || currentGameState === GameState.GAME_OVER || currentGameState === GameState.MENU) { if (knightImageEl.style.display === 'none') { knightImageEl.style.display = 'block'; } } else { knightImageEl.style.display = 'none'; } }

            function displayPOIInfo(poiId) { /* ... */ const poi = poiData.find(p => p.id === poiId); if (!poi) { console.warn(`POI data not found for ID: ${poiId}`); return; } isPaused = true; console.log(`>>> Game PAUSED for POI ID: ${poiId}`); poiNameEl.textContent = poi.name; const infoParts = poi.info.split('|').map(s => s.trim()); const formattedInfo = infoParts.join('<br><br>'); poiInfoTextEl.innerHTML = formattedInfo; console.log(">>> Set POI text using .innerHTML"); poiOverlay.classList.add('visible'); console.log(">>> Added 'visible' class to poiOverlay."); }
            function closePoiOverlay() { /* ... */ console.log("closePoiOverlay function called by event"); poiOverlay.classList.remove('visible'); isPaused = false; lastTime = performance.now(); console.log(">>> Closed POI Overlay. Game RESUMED."); }

            function gameLoop(timestamp) { /* ... */
                 const dt = (timestamp - lastTime) / 1000 || 0; if (!isPaused) { lastTime = timestamp; }
                 if (currentGameState === GameState.PLAYING && !isPaused) { /* ... collision checks, updates ... */
                    let collisionHandledThisFrame = false; const collisionResult = checkCollisions();
                    if (collisionResult.type === CollisionType.SIDE) { playSound('hit'); playerLives--; currentLivesSpan.textContent = playerLives; collisionHandledThisFrame = true; if (playerLives > 0) { console.log(`Life lost! ${playerLives} remaining.`); player.y = canvasHeight - groundHeightPx - player.height; player.dy = 0; player.grounded = true; playerInvincibleUntil = performance.now() + INVINCIBILITY_DURATION_MS; console.log(`Player invincible until ${playerInvincibleUntil.toFixed(0)}`); } else { console.warn("GAME OVER - No lives left."); currentGameState = GameState.GAME_OVER; saveHighScore(); finalScoreSpan.textContent = score; gameOverHighScoreSpan.textContent = highScore; gameOverScreen.classList.remove('hidden'); scoreDisplay.classList.add('hidden'); livesDisplay.classList.add('hidden'); knightImageEl.style.display = 'none'; if (poiOverlay.classList.contains('visible')) { closePoiOverlay(); } } }
                    else if (collisionResult.type === CollisionType.TOP) { player.y = collisionResult.obstacle.y - player.height; player.dy = player.jumpPower * PLAYER_BOUNCE_POWER_MULTIPLIER; player.grounded = false; playSound('bounce'); collisionResult.obstacle.isKnocked = true; console.log(`Knocked off: ${collisionResult.obstacle.assetKey}`); updatePlayer(dt); collisionHandledThisFrame = true; }
                    if (!collisionHandledThisFrame) { updatePlayer(dt); } if (currentGameState === GameState.PLAYING) { updateObstacles(dt, timestamp); updateScoreAndSpeed(); } }
                 ctx.clearRect(0, 0, canvasWidth, canvasHeight); drawBackground(dt); drawObstacles(); updateKnightVisuals();
                 if (currentGameState === GameState.LOADING) { /* ... draw loading ... */ ctx.fillStyle = 'white'; ctx.font = '20px ' + getComputedStyle(document.body).getPropertyValue('--font-pixel'); ctx.textAlign = 'center'; ctx.fillText('Loading Assets...', canvasWidth / 2, canvasHeight / 2); }
                requestAnimationFrame(gameLoop);
            }

            function startGame() { /* ... */ console.log("Attempting startGame(). Current state:", currentGameState, "Assets loaded?", allAssetsLoaded); if (currentGameState === GameState.PLAYING || !allAssetsLoaded) { console.log("startGame() aborted."); return; } console.log("Executing startGame()..."); resetGame(); currentGameState = GameState.PLAYING; startScreen.classList.add('hidden'); gameOverScreen.classList.add('hidden'); scoreDisplay.classList.remove('hidden'); livesDisplay.classList.remove('hidden'); knightImageEl.style.display = 'block'; knightImageEl.style.opacity = '1'; currentKnightVisualState = null; updateKnightVisuals(); playSound('start'); lastTime = performance.now(); }
            function restartGame() { /* ... */ console.log("Attempting restartGame(). Current state:", currentGameState); if (currentGameState === GameState.PLAYING || !allAssetsLoaded) return; console.log("Executing restartGame()..."); startGame(); }
            function handleJumpInput() { /* ... */ if (currentGameState === GameState.PLAYING && !isPaused && player.grounded) { player.dy = player.jumpPower; player.grounded = false; playSound('jump'); } }

            // --- Input Event Handlers ---
            function handleKeyDown(e) { /* ... */ if ((e.key === 'Enter' || e.keyCode === 13) && isPaused && poiOverlay.classList.contains('visible')) { e.preventDefault(); console.log("Enter key pressed while POI visible. Closing POI."); closePoiOverlay(); return; } if (e.key === ' ' || e.code === 'Space') { e.preventDefault(); if (!allAssetsLoaded) return; switch (currentGameState) { case GameState.PLAYING: handleJumpInput(); break; case GameState.MENU: startGame(); break; case GameState.GAME_OVER: restartGame(); break; } } }
            // --- MODIFIED: handleMouseClick (New function for mouse input) ---
            function handleMouseClick(e) {
                 // Ignore clicks on buttons within the overlay
                 if (e.target === closePoiButton || e.target === startButton || e.target === restartButton) {
                     return;
                 }
                 console.log("Mouse click detected. Current state:", currentGameState, "Assets loaded?", allAssetsLoaded, "Target:", e.target.id);
                 if (!allAssetsLoaded) return;

                 // If POI is visible, let its own click listener handle it (added in initGame)
                 if (isPaused && poiOverlay.classList.contains('visible')) {
                     console.log("Mouse click ignored: POI overlay is visible.");
                     return;
                 }

                 switch (currentGameState) {
                     case GameState.PLAYING:
                         handleJumpInput(); // Jump if playing and not paused
                         break;
                     case GameState.MENU:
                         startGame(); // Start game from menu on click
                         break;
                     case GameState.GAME_OVER:
                         restartGame(); // Restart game from game over on click
                         break;
                 }
            }
            function handleScreenTouch(e) { /* ... */ e.preventDefault(); if (!allAssetsLoaded) return; /* Let overlay listener handle close */ switch (currentGameState) { case GameState.PLAYING: if (!isPaused) { handleJumpInput(); } break; case GameState.MENU: if (e.target === startButton || e.target === canvas || e.target === gameContainer) { startGame(); } break; case GameState.GAME_OVER: if (e.target === restartButton || e.target === canvas || e.target === gameContainer) { restartGame(); } break; } }

             function resizeCanvas() { /* ... */ const containerWidth = gameContainer.clientWidth; const containerHeight = gameContainer.clientHeight; canvasWidth = containerWidth; canvasHeight = containerHeight; canvas.width = canvasWidth; canvas.height = canvasHeight; console.log(`Canvas resized to: ${canvasWidth}x${canvasHeight}`); if (gameInitialized) { console.log("Recalculating dynamic values on resize..."); resetGame(); currentGameState = GameState.MENU; startScreen.classList.remove('hidden'); gameOverScreen.classList.add('hidden'); scoreDisplay.classList.add('hidden'); livesDisplay.classList.add('hidden'); knightImageEl.style.display = 'none'; } }

            // --- MODIFIED: Initial Setup (Adds mouse click listener) ---
            function initGame() {
                if (gameInitialized || !allAssetsLoaded) return;
                console.log("Initializing Game...");
                gameInitialized = true;
                if (!assets.knight_run.loaded || !assets.knight_jump.loaded) { console.error("Knight run/jump assets failed to load! Cannot start."); alert("Error: Essential knight images failed to load. Please check paths or refresh."); return; }
                loadHighScore(); resizeCanvas(); startScreen.classList.remove('hidden'); gameOverScreen.classList.add('hidden'); scoreDisplay.classList.add('hidden'); livesDisplay.classList.add('hidden'); poiOverlay.classList.remove('visible'); knightImageEl.style.display = 'none';

                 // Remove potentially old listeners first
                 startButton.removeEventListener('click', startGame);
                 restartButton.removeEventListener('click', restartGame);
                 document.removeEventListener('keydown', handleKeyDown);
                 gameContainer.removeEventListener('touchstart', handleScreenTouch);
                 gameContainer.removeEventListener('click', handleMouseClick); // Remove old mouse listener
                 window.removeEventListener('resize', resizeCanvas);
                 closePoiButton.removeEventListener('click', closePoiOverlay);
                 poiOverlay.removeEventListener('click', closePoiOverlay);

                 // Add listeners
                 console.log("Attaching listeners...");
                 startButton.addEventListener('click', startGame);
                 restartButton.addEventListener('click', restartGame);
                 document.addEventListener('keydown', handleKeyDown);
                 gameContainer.addEventListener('touchstart', handleScreenTouch, { passive: false });
                 gameContainer.addEventListener('click', handleMouseClick); // NEW: Add mouse click listener
                 window.addEventListener('resize', resizeCanvas);
                 closePoiButton.addEventListener('click', closePoiOverlay);
                 poiOverlay.addEventListener('click', closePoiOverlay);
                 console.log("Event listeners attached.");

                 currentGameState = GameState.MENU;
                 console.log("Set gameState to MENU");
                 lastTime = performance.now();
                 requestAnimationFrame(gameLoop);
                 console.log("Initial game loop requested.");
            }

            // --- Start Asset Loading ---
            document.addEventListener('DOMContentLoaded', () => { console.log("DOM Ready. Starting asset load."); loadAssets(); });

        })(); // End of IIFE
    </script>
</body>
</html>
