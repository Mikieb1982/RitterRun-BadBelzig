<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>RitterRun - Bad Belzig</title> <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        /* Basic Reset & Body Styling */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { display: flex; justify-content: center; align-items: center; width: 100%; height: 100vh; overflow: hidden; background-color: #151513; font-family: Arial, sans-serif; touch-action: manipulation; }
        /* Game Container - Scaled Responsively */
        #gameContainer { position: relative; width: 95vw; height: calc(95vw / 2); max-height: 95vh; max-width: calc(95vh * 2); overflow: hidden; margin: auto; background: #000; }
        /* Canvas Styling */
        #gameCanvas { display: block; width: 100%; height: 100%; background-color: #0296c6; }
        /* Score Display Styling */
        #scoreDisplay { position: absolute; top: 1.5vh; left: 2vw; color: #ffffff; background-color: rgba(21, 21, 19, 0.7); padding: 0.8vh 1.5vw; border-radius: 3px; font-size: max(1.2em, 2.5vw); z-index: 10; white-space: nowrap; }
        /* Lives Display Styling */
        #livesDisplay { position: absolute; top: 1.5vh; right: 2vw; color: #ffffff; background-color: rgba(21, 21, 19, 0.7); padding: 0.8vh 1.5vw; border-radius: 3px; font-size: max(1.2em, 2.5vw); z-index: 10; white-space: nowrap; }
        /* Common Styles for Popups and Overlays */
        .popup, .overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: none; flex-direction: column; justify-content: center; align-items: center; text-align: center; color: #ffffff; padding: 3vw; z-index: 20; box-sizing: border-box; }
        /* Specific Overlay Backgrounds */
        .overlay { background-color: rgba(21, 21, 19, 0.85); }
        .popup { background-color: rgba(21, 21, 19, 0.95); border: max(2px, 0.5vmin) solid #f5d306; max-width: 85%; max-height: 85%; border-radius: 8px; overflow-y: auto; }
        /* Text Styling within Overlays */
        .popup h3, .overlay h2 { color: #f5d306; margin-bottom: 2vh; font-size: max(1.2em, 3vw); font-family: 'Press Start 2P', cursive; }
        .popup p, .overlay p { margin-bottom: 1.5vh; line-height: 1.4; font-size: max(0.9em, 1.8vw); max-width: 90%; }
        /* Button Styling */
        #continueButton, .overlay button { padding: 1.5vh 3vw; background-color: #f5d306; color: #151513; border: none; border-radius: 5px; font-size: max(1em, 2.5vw); font-weight: bold; cursor: pointer; margin-top: 2vh; min-width: 25vw; min-height: 6vh; transition: background-color 0.2s ease; font-family: 'Press Start 2P', cursive; }
        #continueButton:hover, .overlay button:hover { background-color: #e0bd05; }
        /* Mobile Orientation Message */
        #rotateDeviceMessage { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: #151513; color: #ffffff; z-index: 100; flex-direction: column; justify-content: center; align-items: center; text-align: center; font-size: max(1.2em, 4vw); padding: 5vw; }
        @media (orientation: portrait) { #rotateDeviceMessage { display: flex; } #gameContainer { display: none; } }
    </style>
</head>
<body>

    <div id="rotateDeviceMessage">
        Please rotate your device to landscape mode to play.
        <br><br>
        Bitte drehe dein Gerät ins Querformat zum Spielen.
    </div>

    <div id="gameContainer"> <canvas id="gameCanvas" width="800" height="400"></canvas>
        <div class="game-info">
            <span id="scoreDisplay">Punkte / Score: 0</span>
            <span id="livesDisplay">Leben / Lives: 5</span>
        </div>

        <div id="landmarkPopup" class="popup">
             <div class="popup-content"> <h3 id="landmarkName">Landmark Name</h3>
                <p id="landmarkDescription">Landmark description goes here...</p>
                <button id="continueButton">Continue / Weiter</button>
            </div>
        </div>

        <div id="gameOverScreen" class="overlay">
             <div class="popup-content"> <h2>Game Over!</h2> <p>Du hast verloren. Klicke zum Neustarten.</p> <button>Retry / Nochmal</button>
            </div>
        </div>

        <div id="winScreen" class="overlay">
             <div class="popup-content"> <h2>Gewonnen! / You Win!</h2> <p>Glückwunsch! Du hast die Burg Eisenhardt erreicht! Klicke zum Neustarten.</p> <button>Play Again / Nochmal Spielen</button>
            </div>
        </div>
    </div>

    <script>
        // --- Get DOM Elements ---
        // Now this runs after the elements are loaded
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d'); // This should work now
        const scoreDisplay = document.getElementById('scoreDisplay');
        const livesDisplay = document.getElementById('livesDisplay');
        const landmarkPopup = document.getElementById('landmarkPopup');
        const landmarkName = document.getElementById('landmarkName');
        const landmarkDescription = document.getElementById('landmarkDescription');
        const continueButton = document.getElementById('continueButton');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const winScreen = document.getElementById('winScreen');

        // --- Game Configuration ---
        const config = {
            canvasWidth: canvas.width, // Initial values, will be updated
            canvasHeight: canvas.height, // Initial values, will be updated
            gravity: 0.45,
            jumpStrength: -10.5, // Base jump strength
            playerSpeed: 0,
            obstacleSpeed: 2.2, // Base obstacle speed
            groundHeight: 50, // Logical ground height
            spawnRate: 160,
            jumpHoldGravityMultiplier: 0.5,
            jumpCutGravityMultiplier: 2.0,
            stompJumpStrength: -8.5, // Base stomp strength
            maxGameSpeed: 7, // Base max speed
            startLives: 5,
            recoveryDuration: 90,
            colors: { green: '#0ca644', blue: '#0296c6', yellow: '#f5d306', black: '#151513', white: '#ffffff', ground: '#8b4513' }
        };

        // --- Game State Variables ---
        let gameState = 'loading';
        let playerState = {};
        let obstacles = [];
        let landmarks = [];
        let score = 0;
        let frameCount = 0;
        let gameSpeed = config.obstacleSpeed;
        let isJumpKeyDown = false;
        let isPointerDownJump = false;
        let playerLives = config.startLives;
        let isRecovering = false;
        let recoveryTimer = 0;
        let backgroundX = 0;

        // --- Asset Loading ---
        const assets = {
            knightPlaceholder: null, stoneObstacle: null, familyObstacle: null,
            tractorObstacle: null, backgroundImage: null, signImage: null,
            loaded: 0, total: 0,
            // *** Using Placeholders URLs again to ensure it runs ***
            // If you have images in an 'assets' folder, replace these URLs with 'assets/filename.png'
            sources: {
                knightPlaceholder: 'https://placehold.co/60x75/0ca644/ffffff?text=Knight',
                stoneObstacle: 'https://placehold.co/30x40/a0a0a0/ffffff?text=Stone',
                familyObstacle: 'https://placehold.co/70x100/0296c6/ffffff?text=Family',
                tractorObstacle: 'https://placehold.co/115x80/f5d306/151513?text=Tractor',
                backgroundImage: 'https://placehold.co/800x350/e0f2fe/888888?text=Background',
                signImage: 'https://placehold.co/60x90/8b4513/ffffff?text=Sign'
            }
        };

        function loadImage(key, src) {
            assets.total++;
            const img = new Image();
            img.src = src;
            img.onerror = () => {
                console.error(`Failed to load asset: ${key} from ${src}.`); // Log error
                assets.loaded++;
                assets[key] = null; // Mark as failed
                if (assets.loaded === assets.total) {
                    console.log("Asset loading finished.");
                    setupCanvas(); // Setup canvas after trying all loads
                    resetGame();
                }
            };
            img.onload = () => {
                assets.loaded++;
                assets[key] = img;
                if (assets.loaded === assets.total) {
                    console.log("All assets loaded.");
                    setupCanvas(); // Setup canvas after successful loads
                    resetGame();
                }
            };
        }

        function loadAllAssets() {
            console.log("Starting asset loading...");
            gameState = 'loading';
            for (const key in assets.sources) { assets[key] = null; }
            assets.loaded = 0; assets.total = 0;
            for (const key in assets.sources) { loadImage(key, assets.sources[key]); }
            if (assets.total === 0) {
                console.warn("No assets defined.");
                setupCanvas(); // Setup canvas even if no assets
                resetGame();
            }
        }
        // --- END Asset Loading ---

        // --- Canvas Setup ---
        function setupCanvas() {
            const container = document.getElementById('gameContainer');
            if (!container) {
                console.error("Game container not found!");
                return;
            }
            // Set canvas logical size to match its CSS-defined display size
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            // Update config dimensions
            config.canvasWidth = canvas.width;
            config.canvasHeight = canvas.height;
            console.log(`Canvas resized to: ${canvas.width}x${canvas.height}`);
            // Recalculate dependent values if needed (e.g., ground level, player size)
            // This might require adjusting resetPlayer and initializeLandmarks
        }

        window.addEventListener('resize', () => {
            if (window.matchMedia("(orientation: landscape)").matches) {
                 setupCanvas();
                 // Redraw immediately if game is running or paused to avoid blank canvas
                 if (gameState === 'running' || gameState === 'paused' || gameState === 'loading') {
                     // If loading, assets might not be ready, just clear
                     if (gameState === 'loading') {
                         ctx.clearRect(0, 0, config.canvasWidth, config.canvasHeight);
                     } else {
                         draw(); // Redraw with current state
                     }
                 }
            }
        });
        // --- END Canvas Setup ---

        // --- Landmark Data (Shortened descriptions) ---
        const landmarkConfig = [
             { name: "SteinTherme", worldX: 1500, width: 60, height: 90, descEN: "Relax in the SteinTherme! Bad Belzig's unique thermal bath...", descDE: "Entspann dich in der SteinTherme! Bad Belzigs einzigartiges Thermalbad...", isFinal: false },
             { name: "Frei und Erlebnisbad", worldX: 3000, width: 60, height: 90, descEN: "Cool off at the Freibad! This outdoor pool is popular...", descDE: "Kühl dich ab im Freibad! Dieses Freibad ist im Sommer beliebt...", isFinal: false },
             { name: "Kulturzentrum & Bibliothek", worldX: 4500, width: 60, height: 90, descEN: "This building houses the town library and cultural centre.", descDE: "Dieses Gebäude beherbergt die Stadtbibliothek und das Kulturzentrum.", isFinal: false },
             { name: "Fläming Bahnhof", worldX: 6000, width: 60, height: 90, descEN: "All aboard at Fläming Bahnhof! The RE7 train line connects...", descDE: "Einsteigen bitte am Fläming Bahnhof! Die Zuglinie RE7 verbindet...", isFinal: false },
             { name: "Postmeilensäule", worldX: 7500, width: 60, height: 90, descEN: "See how far? This sandstone Postal Milestone from 1725...", descDE: "Schon gesehen? Diese kursächsische Postmeilensäule...", isFinal: false },
             { name: "Rathaus & Tourist-Information", worldX: 9000, width: 60, height: 90, descEN: "The historic Rathaus (Town Hall) sits centrally...", descDE: "Das historische Rathaus befindet sich zentral am Marktplatz...", isFinal: false },
             { name: "Burg Eisenhardt", worldX: 10500, width: 60, height: 90, descEN: "You made it to Burg Eisenhardt! This impressive medieval castle...", descDE: "Geschafft! Du hast die Burg Eisenhardt erreicht! Diese Burg...", isFinal: true },
        ];

        function initializeLandmarks() {
            // Use current canvas dimensions for positioning
            const currentCanvasHeight = config.canvasHeight;
            const baseSignHeight = 90; // Base height used for scaling
            const scaleFactor = currentCanvasHeight / 400; // Scale based on design height
            const scaledSignHeight = baseSignHeight * scaleFactor;

            landmarks = landmarkConfig.map(cfg => ({
                ...cfg,
                // Position based on scaled sign height and logical ground
                yPos: currentCanvasHeight - config.groundHeight - scaledSignHeight,
                hasBeenTriggered: false
            }));
        }
        // --- END Landmark Data ---

        // --- Player State Initialization ---
        function resetPlayer() {
            // Use current canvas dimensions
            const currentCanvasHeight = config.canvasHeight;
            // Scale player size based on canvas height
            const playerHeight = currentCanvasHeight * 0.15; // e.g., 15% of canvas height
            const playerWidth = playerHeight * (60/75); // Maintain aspect ratio (60/75)

            playerState = {
                x: 50, // Keep start x fixed for now
                y: currentCanvasHeight - config.groundHeight - playerHeight,
                width: playerWidth, height: playerHeight,
                vy: 0, isGrounded: true
            };
        }

        // --- Game Reset Function ---
        function resetGame() {
            console.log("Resetting game...");
            // Ensure canvas dimensions are current
            setupCanvas(); // Call setup again to be sure

            resetPlayer();
            obstacles = [];
            initializeLandmarks();
            score = 0;
            frameCount = 0;
            gameSpeed = config.obstacleSpeed; // Reset to base speed
            isJumpKeyDown = false;
            isPointerDownJump = false;
            playerLives = config.startLives;
            isRecovering = false;
            recoveryTimer = 0;
            backgroundX = 0;

            livesDisplay.textContent = `Leben / Lives: ${playerLives}`;
            scoreDisplay.textContent = `Punkte / Score: 0`;
            gameOverScreen.style.display = 'none';
            winScreen.style.display = 'none';
            landmarkPopup.style.display = 'none';

            gameState = 'running';
            requestAnimationFrame(gameLoop);
        }

        // --- Input Handling ---
        function handleJump() {
            if (gameState === 'running' && playerState.isGrounded) {
                // Scale jump strength based on canvas height (relative to original 400px design)
                playerState.vy = config.jumpStrength * (config.canvasHeight / 400);
                playerState.isGrounded = false;
            } else if (gameState === 'gameOver' && gameOverScreen.style.display !== 'none') {
                resetGame();
            } else if (gameState === 'win' && winScreen.style.display !== 'none') {
                resetGame();
            }
        }

        function hideLandmarkPopup() {
            const popupIsVisible = landmarkPopup.style.display !== 'none';
            if (!popupIsVisible) return;
            landmarkPopup.style.display = 'none';
            if (gameState === 'win') { showWinScreen(); }
            else if (gameState === 'paused') {
                gameState = 'running';
                requestAnimationFrame(gameLoop);
            }
        }

        // Event listeners (no changes needed here for the fix)
        window.addEventListener('keydown', (e) => {
            if (e.code === 'Space') { e.preventDefault(); if (!isJumpKeyDown) { handleJump(); } isJumpKeyDown = true; }
            else if (e.key === 'Enter' || e.code === 'Enter') {
                e.preventDefault();
                if ((gameState === 'paused' || gameState === 'win') && landmarkPopup.style.display !== 'none') { hideLandmarkPopup(); }
                else if (gameState === 'gameOver' && gameOverScreen.style.display !== 'none') { resetGame(); }
                else if (gameState === 'win' && winScreen.style.display !== 'none') { resetGame(); }
            }
        });
        window.addEventListener('keyup', (e) => { if (e.code === 'Space') { e.preventDefault(); isJumpKeyDown = false; } });
        canvas.addEventListener('touchstart', (e) => { e.preventDefault(); if (gameState === 'running' || gameState === 'paused') { handleJump(); isPointerDownJump = true; } else if (gameState === 'gameOver') { resetGame(); } else if (gameState === 'win') { resetGame(); } });
        canvas.addEventListener('mousedown', (e) => { if (gameState === 'running') { handleJump(); isPointerDownJump = true; } });
        window.addEventListener('touchend', (e) => { isPointerDownJump = false; });
        window.addEventListener('mouseup', (e) => { isPointerDownJump = false; });
        gameOverScreen.addEventListener('click', resetGame);
        winScreen.addEventListener('click', resetGame);
        continueButton.addEventListener('click', hideLandmarkPopup);
        // --- END Input Handling ---

        // --- Collision Detection ---
        function checkCollision(rect1, rect2) { return ( rect1.x < rect2.x + rect2.width && rect1.x + rect1.width > rect2.x && rect1.y < rect2.y + rect2.height && rect1.y + rect1.height > rect2.y ); }

        // --- Obstacle Handling ---
        const obstacleTypes = ['stoneObstacle', 'familyObstacle', 'tractorObstacle'];
        function spawnObstacle() {
            const typeIndex = Math.floor(Math.random() * obstacleTypes.length);
            const selectedTypeKey = obstacleTypes[typeIndex];
            let baseHeight, baseWidth;
            switch (selectedTypeKey) {
                case 'familyObstacle': baseHeight = 100; baseWidth = 70; break;
                case 'tractorObstacle': baseHeight = 80; baseWidth = 115; break;
                case 'stoneObstacle': default: baseHeight = 40; baseWidth = 30; break;
            }
            const scaleFactor = config.canvasHeight / 400; // Scale based on design height
            let obstacleHeight = (baseHeight + Math.random() * (baseHeight * 0.3)) * scaleFactor;
            let obstacleWidth = (baseWidth + Math.random() * (baseWidth * 0.2)) * scaleFactor;

            obstacles.push({ x: config.canvasWidth, y: config.canvasHeight - config.groundHeight - obstacleHeight, width: obstacleWidth, height: obstacleHeight, typeKey: selectedTypeKey });
        }
        function updateObstacles() {
             // Scale speed based on canvas width (relative to original 800px design)
             const scaledGameSpeed = gameSpeed * (config.canvasWidth / 800);
            if (frameCount > 100 && frameCount % config.spawnRate === 0) { spawnObstacle(); }
            for (let i = obstacles.length - 1; i >= 0; i--) {
                obstacles[i].x -= scaledGameSpeed; // Use scaled speed
                if (obstacles[i].x + obstacles[i].width < 0) { obstacles.splice(i, 1); }
            }
        }
        // --- END Obstacle Handling ---

        // --- Landmark Display ---
        function showLandmarkPopup(landmark) { landmarkName.textContent = landmark.name; landmarkDescription.innerHTML = `${landmark.descEN}<br><br>${landmark.descDE}`; landmarkPopup.style.display = 'flex'; }

        // --- Update Game State ---
        function update() {
            if (gameState !== 'running') return;
            frameCount++;
            if (isRecovering) { if (--recoveryTimer <= 0) { isRecovering = false; } }

            // Physics - Scale gravity based on canvas height
            let currentGravity = config.gravity * (config.canvasHeight / 400);
            if (!playerState.isGrounded && playerState.vy < 0) {
                if (isJumpKeyDown || isPointerDownJump) { currentGravity *= config.jumpHoldGravityMultiplier; }
                else { currentGravity *= config.jumpCutGravityMultiplier; }
            }
            playerState.vy += currentGravity;
            playerState.y += playerState.vy;

            // Ground collision
            const groundLevel = config.canvasHeight - config.groundHeight - playerState.height;
            if (playerState.y >= groundLevel) { playerState.y = groundLevel; playerState.vy = 0; playerState.isGrounded = true; }
            else { playerState.isGrounded = false; }

            updateObstacles(); // Obstacle speed scaling is inside this function

            // Collision Checks
            if (!isRecovering) {
                for (let i = obstacles.length - 1; i >= 0; i--) {
                    const obstacle = obstacles[i];
                    if (checkCollision(playerState, obstacle)) {
                        const isFalling = playerState.vy > 0;
                        const previousPlayerBottom = playerState.y + playerState.height - playerState.vy;
                        const obstacleTop = obstacle.y;
                        if (isFalling && previousPlayerBottom <= obstacleTop + 1) { // Stomp
                            // Scale stomp jump strength
                            playerState.vy = config.stompJumpStrength * (config.canvasHeight / 400);
                            playerState.y = obstacle.y - playerState.height;
                            playerState.isGrounded = false; score += 50; obstacles.splice(i, 1); continue;
                        } else { // Hit
                             playerLives--; livesDisplay.textContent = `Leben / Lives: ${playerLives}`;
                             score -= 75; if (score < 0) { score = 0; }
                             if (playerLives <= 0) { gameState = 'gameOver'; showGameOverScreen(); return; }
                             else { isRecovering = true; recoveryTimer = config.recoveryDuration; playerState.vy = -3 * (config.canvasHeight / 400); playerState.isGrounded = false; break; } // Scale bounce back slightly
                        }
                    }
                }
            }

            // Landmark Triggers - Scale speed based on canvas width
            const scaledGameSpeed = gameSpeed * (config.canvasWidth / 800);
            for (let landmark of landmarks) {
                landmark.worldX -= scaledGameSpeed;
                if (!landmark.hasBeenTriggered && landmark.worldX < playerState.x + playerState.width && landmark.worldX + landmark.width > playerState.x) {
                    landmark.hasBeenTriggered = true; showLandmarkPopup(landmark);
                    if (landmark.isFinal) { gameState = 'win'; } else { gameState = 'paused'; }
                    return;
                }
            }

            // Score update
            score++; scoreDisplay.textContent = `Punkte / Score: ${Math.floor(score / 5)}`;

            // Speed increase
            if (frameCount > 0 && frameCount % 240 === 0) {
                if (gameSpeed < config.maxGameSpeed) { // Compare with base max speed
                    gameSpeed += 0.07; gameSpeed = parseFloat(gameSpeed.toFixed(2));
                }
            }

             // Background scroll - use scaled speed
             backgroundX -= scaledGameSpeed * 0.5;
             // Background width scaling needed if image size isn't fixed
             const bgWidth = assets.backgroundImage ? assets.backgroundImage.width * (config.canvasHeight / 400) / (assets.backgroundImage.height / 350) : config.canvasWidth; // Estimate scaled width
             if (assets.backgroundImage && backgroundX <= -bgWidth) { backgroundX += bgWidth; }

        }


        // --- Draw Game ---
        function draw() {
            const canvasW = config.canvasWidth;
            const canvasH = config.canvasHeight;
            ctx.clearRect(0, 0, canvasW, canvasH);

             // Draw Background
             if (assets.backgroundImage) {
                 const scaleFactor = (canvasH - config.groundHeight) / assets.backgroundImage.height; // Scale to fit height above ground
                 const scaledBgWidth = assets.backgroundImage.width * scaleFactor;
                 let currentX = backgroundX % scaledBgWidth;
                 if (currentX > 0) currentX -= scaledBgWidth;

                 while (currentX < canvasW) {
                     ctx.drawImage(assets.backgroundImage, 0, 0, assets.backgroundImage.width, assets.backgroundImage.height,
                                   currentX, 0, scaledBgWidth, canvasH - config.groundHeight);
                     currentX += scaledBgWidth;
                 }
             } else { ctx.fillStyle = config.colors.blue; ctx.fillRect(0, 0, canvasW, canvasH - config.groundHeight); }

             // Draw visual ground
             ctx.fillStyle = config.colors.ground;
             ctx.fillRect(0, canvasH - config.groundHeight, canvasW, config.groundHeight);

            // Draw Player
            let drawPlayer = true;
            if (isRecovering && frameCount % 10 < 5) { drawPlayer = false; }
            if (drawPlayer) {
                if (assets.knightPlaceholder) { ctx.drawImage(assets.knightPlaceholder, playerState.x, playerState.y, playerState.width, playerState.height); }
                else { ctx.fillStyle = config.colors.green; ctx.fillRect(playerState.x, playerState.y, playerState.width, playerState.height); }
            }

            // Draw Obstacles
            obstacles.forEach(obstacle => {
                const obstacleImage = assets[obstacle.typeKey];
                if (obstacleImage) { ctx.drawImage(obstacleImage, obstacle.x, obstacle.y, obstacle.width, obstacle.height); }
                else { ctx.fillStyle = config.colors.black; ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height); }
            });

            // Draw Landmark Signs
            landmarks.forEach(landmark => {
                 // Use current canvas dimensions for checks and drawing
                 const scaleFactor = config.canvasHeight / 400; // Relative to original design height
                 const signW = (landmark.width || 60) * scaleFactor;
                 const signH = (landmark.height || 90) * scaleFactor;
                 // Recalculate Y position based on current dimensions and scaled height
                 const signY = config.canvasHeight - config.groundHeight - signH;

                 if (landmark.worldX < config.canvasWidth && landmark.worldX + signW > 0) { // Use scaled width for check
                     if (assets.signImage) { ctx.drawImage(assets.signImage, landmark.worldX, signY, signW, signH); }
                     else { ctx.fillStyle = config.colors.ground; ctx.fillRect(landmark.worldX, signY, signW, signH); }
                 }
            });
        }
        // --- END Draw Game ---

        // --- UI Updates ---
        function showGameOverScreen() { gameOverScreen.style.display = 'flex'; }
        function showWinScreen() { winScreen.style.display = 'flex'; }

        // --- Main Game Loop ---
        function gameLoop() {
            if (gameState !== 'running') { return; }
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        // --- Start Game ---
        // Initial setup on load
        // setupCanvas(); // Setup canvas size first - Moved to asset load callback
        loadAllAssets(); // Load assets, which calls setupCanvas and resetGame
        // --- END Start Game ---

    </script>

</body>
</html>
