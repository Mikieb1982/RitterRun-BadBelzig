<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"> <title>Bad Belzig Runner</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        /* Basic Reset & Body Styling */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
            height: 100vh;
            overflow: hidden; /* Prevent scrollbars on body */
            background-color: #151513; /* Dark background for the page */
            font-family: Arial, sans-serif;
            touch-action: manipulation; /* Improve touch responsiveness */
        }

        /* Game Container - Scaled Responsively */
        #gameContainer {
            position: relative;
            /* Responsive sizing based on viewport width, maintaining aspect ratio */
            width: 95vw;
            height: calc(95vw / 2); /* Maintain a 2:1 aspect ratio */
            /* Limit size based on viewport height */
            max-height: 95vh;
            max-width: calc(95vh * 2); /* Max width based on max height and ratio */
            overflow: hidden; /* Hide anything outside the container */
            margin: auto; /* Center container */
            background: #000; /* Fallback background */
        }

        /* Canvas Styling */
        #gameCanvas {
            display: block; /* Remove extra space below canvas */
            width: 100%;
            height: 100%;
            background-color: #0296c6; /* Blue sky background */
        }

        /* Score Display Styling */
        #scoreDisplay {
            position: absolute;
            top: 1.5vh; /* Position from top based on viewport height */
            left: 2vw; /* Position from left based on viewport width */
            color: #ffffff;
            background-color: rgba(21, 21, 19, 0.7); /* Semi-transparent dark background */
            padding: 0.8vh 1.5vw; /* Padding based on viewport dimensions */
            border-radius: 3px;
            /* Responsive font size, minimum 1.2em */
            font-size: max(1.2em, 2.5vw);
            z-index: 10; /* Ensure it's above the canvas */
            white-space: nowrap; /* Prevent text wrapping */
        }

        /* Lives Display Styling - ADDED */
        #livesDisplay {
            position: absolute;
            top: 1.5vh;    /* Align with score display vertically */
            right: 2vw;   /* Position on the right */
            color: #ffffff;
            background-color: rgba(21, 21, 19, 0.7);
            padding: 0.8vh 1.5vw;
            border-radius: 3px;
            font-size: max(1.2em, 2.5vw); /* Match score font size */
            z-index: 10; /* Above canvas */
            white-space: nowrap;
        }

        /* Common Styles for Popups and Overlays */
        .popup,
        .overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            display: none; /* Hidden by default */
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            color: #ffffff;
            padding: 3vw; /* Padding based on viewport width */
            z-index: 20; /* Ensure overlays are on top */
            box-sizing: border-box; /* Include padding in dimensions */
        }

        /* Specific Overlay Backgrounds */
        .overlay { /* Game Over / Win screens */
            background-color: rgba(21, 21, 19, 0.85); /* Darker overlay */
        }

        .popup { /* Landmark Info popup */
             background-color: rgba(21, 21, 19, 0.95); /* Even darker popup */
             border: max(2px, 0.5vmin) solid #f5d306; /* Yellow border, scales slightly */
             max-width: 85%; max-height: 85%; /* Limit popup size */
             border-radius: 8px;
             overflow-y: auto; /* Allow scrolling if content overflows */
        }


        /* Text Styling within Overlays (Responsive fonts) */
        .popup h3, .overlay h2 { /* Different heading levels targeted */
            color: #f5d306; /* Yellow heading color */
            margin-bottom: 2vh; /* Space below heading */
            font-size: max(1.2em, 3vw); /* Responsive font size */
            font-family: 'Press Start 2P', cursive; /* Use game font for titles */
        }

        .popup p, .overlay p {
            margin-bottom: 1.5vh; /* Space below paragraphs */
            line-height: 1.4; /* Improve readability */
            font-size: max(0.9em, 1.8vw); /* Responsive font size for text */
            max-width: 90%; /* Prevent text stretching too wide */
        }

        /* Button Styling */
        #continueButton, .overlay button { /* Style continue and overlay buttons */
            padding: 1.5vh 3vw; /* Responsive padding */
            background-color: #f5d306; /* Yellow background */
            color: #151513; /* Dark text */
            border: none; border-radius: 5px;
            font-size: max(1em, 2.5vw); font-weight: bold; /* Responsive font */
            cursor: pointer; margin-top: 2vh; /* Space above button */
            min-width: 25vw; min-height: 6vh; /* Minimum size */
            transition: background-color 0.2s ease;
            font-family: 'Press Start 2P', cursive; /* Game font for buttons */
        }
        #continueButton:hover, .overlay button:hover {
             background-color: #e0bd05; /* Darker yellow on hover */
        }

        /* Mobile Orientation Message */
        #rotateDeviceMessage {
            display: none; /* Hidden by default */
            position: fixed; /* Cover the whole screen */
            top: 0; left: 0; width: 100%; height: 100%;
            background-color: #151513; color: #ffffff;
            z-index: 100; /* Above everything else */
            flex-direction: column; justify-content: center; align-items: center;
            text-align: center; font-size: max(1.2em, 4vw); padding: 5vw;
        }
        /* Show message only in portrait orientation */
        @media (orientation: portrait) {
            #rotateDeviceMessage { display: flex; }
            #gameContainer { display: none; } /* Hide game in portrait */
        }

        /* Removed .ground specific style - handled by canvas background and config.groundHeight */

    </style>
</head>
<body class="bg-gray-100 flex flex-col items-center justify-center min-h-screen p-4">

    <div id="rotateDeviceMessage">
        Please rotate your device to landscape mode to play.
        <br><br>
        Bitte drehe dein Gerät ins Querformat zum Spielen.
    </div>

    <div id="gameContainer" class="rounded-lg shadow-lg">
        <canvas id="gameCanvas" width="800" height="400"></canvas>
        <div class="game-info">
            <span id="scoreDisplay">Punkte / Score: 0</span>
            <span id="livesDisplay">Leben / Lives: 5</span>
        </div>

        <div id="landmarkPopup" class="popup"> <div class="popup-content"> <h3 id="landmarkName">Landmark Name</h3> <p id="landmarkDescription">Landmark description goes here...</p>
                <button id="continueButton">Continue / Weiter</button>
            </div>
        </div>

        <div id="gameOverScreen" class="overlay">
            <div class="popup-content"> <h2 class="end-screen-title">Game Over!</h2> <p class="end-screen-text">Du hast verloren. Klicke zum Neustarten.</p>
                <button>Retry / Nochmal</button>
            </div>
        </div>

        <div id="winScreen" class="overlay">
             <div class="popup-content"> <h2 class="end-screen-title">Gewonnen! / You Win!</h2> <p class="end-screen-text">Glückwunsch! Du hast die Burg Eisenhardt erreicht! Klicke zum Neustarten.</p>
                 <button>Play Again / Nochmal Spielen</button>
            </div>
        </div>
    </div>

    <script>
        // --- Get DOM Elements ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('scoreDisplay');
        const livesDisplay = document.getElementById('livesDisplay');
        const landmarkPopup = document.getElementById('landmarkPopup');
        const landmarkName = document.getElementById('landmarkName');
        const landmarkDescription = document.getElementById('landmarkDescription');
        const continueButton = document.getElementById('continueButton');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const winScreen = document.getElementById('winScreen');

        // --- Game Configuration ---
        const config = {
            // Canvas dimensions will be dynamically read or set based on container size
            canvasWidth: canvas.width, // Initial values, might be updated
            canvasHeight: canvas.height, // Initial values, might be updated
            gravity: 0.45,
            jumpStrength: -10.5,
            playerSpeed: 0,
            obstacleSpeed: 2.2,
            groundHeight: 50, // Logical ground height for positioning, not visual
            spawnRate: 160,
            jumpHoldGravityMultiplier: 0.5,
            jumpCutGravityMultiplier: 2.0,
            stompJumpStrength: -8.5,
            maxGameSpeed: 7,
            startLives: 5,
            recoveryDuration: 90,
            colors: { // Fallback colors if images fail
                green: '#0ca644', blue: '#0296c6', yellow: '#f5d306',
                black: '#151513', white: '#ffffff', ground: '#8b4513' // Ground color kept for potential fallback drawing
            }
        };

        // --- Game State Variables ---
        let gameState = 'loading'; // 'loading', 'running', 'paused', 'gameOver', 'win'
        let playerState = {};
        let obstacles = [];
        let landmarks = [];
        let score = 0;
        let frameCount = 0;
        let gameSpeed = config.obstacleSpeed;
        let isJumpKeyDown = false;
        let isPointerDownJump = false;
        let playerLives = config.startLives;
        let isRecovering = false;
        let recoveryTimer = 0;
        let backgroundX = 0;

        // --- Asset Loading ---
        const assets = {
            knightPlaceholder: null, stoneObstacle: null, familyObstacle: null,
            tractorObstacle: null, backgroundImage: null, signImage: null,
            loaded: 0, total: 0,
            sources: {
                knightPlaceholder: 'https://placehold.co/60x75/0ca644/ffffff?text=Knight',
                stoneObstacle: 'https://placehold.co/30x40/a0a0a0/ffffff?text=Stone',
                familyObstacle: 'https://placehold.co/70x100/0296c6/ffffff?text=Family',
                tractorObstacle: 'https://placehold.co/115x80/f5d306/151513?text=Tractor',
                backgroundImage: 'https://placehold.co/800x350/e0f2fe/888888?text=Background',
                signImage: 'https://placehold.co/60x90/8b4513/ffffff?text=Sign'
            }
        };

        function loadImage(key, src) {
            assets.total++;
            const img = new Image();
            img.src = src;
            img.onerror = () => {
                console.error(`Failed to load asset: ${key} from ${src}. Using fallback.`);
                assets.loaded++;
                assets[key] = null;
                if (assets.loaded === assets.total) {
                    console.log("Asset loading finished (some may have failed). Starting game...");
                    setupCanvas(); // Call setupCanvas before resetGame
                    resetGame();
                }
            };
            img.onload = () => {
                assets.loaded++;
                assets[key] = img;
                if (assets.loaded === assets.total) {
                    console.log("All assets loaded. Starting game...");
                    setupCanvas(); // Call setupCanvas before resetGame
                    resetGame();
                }
            };
        }

        function loadAllAssets() {
            console.log("Starting asset loading...");
            gameState = 'loading';
            for (const key in assets.sources) { assets[key] = null; }
            assets.loaded = 0; assets.total = 0;
            for (const key in assets.sources) { loadImage(key, assets.sources[key]); }
            if (assets.total === 0) {
                console.warn("No assets defined. Starting game immediately.");
                setupCanvas(); // Call setupCanvas before resetGame
                resetGame();
            }
        }
        // --- END Asset Loading ---

        // --- Canvas Setup ---
        // Function to set canvas size based on container
        function setupCanvas() {
            const container = document.getElementById('gameContainer');
            // Set canvas logical size to match its display size
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            // Update config dimensions (optional, but good practice)
            config.canvasWidth = canvas.width;
            config.canvasHeight = canvas.height;
            console.log(`Canvas resized to: ${canvas.width}x${canvas.height}`);
        }

        // Resize canvas when window is resized
        window.addEventListener('resize', () => {
             // Only resize if not in portrait mode (where container is hidden)
            if (window.matchMedia("(orientation: landscape)").matches) {
                 setupCanvas();
                 // Optional: redraw the current frame if game is running/paused
                 if (gameState === 'running' || gameState === 'paused') {
                     draw();
                 }
            }
        });
        // --- END Canvas Setup ---


        // --- Landmark Data ---
        const landmarkConfig = [
             { name: "SteinTherme", worldX: 1500, width: 60, height: 90, descEN: "Relax in the SteinTherme! Bad Belzig's unique thermal bath uses warm, salty water (Sole) rich in iodine...", descDE: "Entspann dich in der SteinTherme! Bad Belzigs einzigartiges Thermalbad nutzt warmes Salzwasser (Sole), reich an Jod...", isFinal: false },
             { name: "Frei und Erlebnisbad", worldX: 3000, width: 60, height: 90, descEN: "Cool off at the Freibad! This outdoor pool is popular in summer...", descDE: "Kühl dich ab im Freibad! Dieses Freibad ist im Sommer beliebt...", isFinal: false },
             { name: "Kulturzentrum & Bibliothek", worldX: 4500, width: 60, height: 90, descEN: "This building at Weitzgrunder Str. 4 houses the town library and the cultural centre.", descDE: "Dieses Gebäude in der Weitzgrunder Str. 4 beherbergt die Stadtbibliothek und das Kulturzentrum..", isFinal: false },
             { name: "Fläming Bahnhof", worldX: 6000, width: 60, height: 90, descEN: "All aboard at Fläming Bahnhof! The RE7 train line connects Bad Belzig directly to Berlin and Dessau...", descDE: "Einsteigen bitte am Fläming Bahnhof! Die Zuglinie RE7 verbindet Bad Belzig direkt mit Berlin und Dessau...", isFinal: false },
             { name: "Postmeilensäule", worldX: 7500, width: 60, height: 90, descEN: "See how far? This sandstone Postal Milestone (Postmeilensäule) from 1725 is located on the Marktplatz...", descDE: "Schon gesehen? Diese kursächsische Postmeilensäule aus Sandstein von 1725 steht auf dem Marktplatz...", isFinal: false },
             { name: "Rathaus & Tourist-Information", worldX: 9000, width: 60, height: 90, descEN: "The historic Rathaus (Town Hall) sits centrally on the Marktplatz. Inside, you'll find the Tourist Information centre...", descDE: "Das historische Rathaus befindet sich zentral am Marktplatz. Im Inneren finden Sie die Tourist-Information...", isFinal: false },
             { name: "Burg Eisenhardt", worldX: 10500, width: 60, height: 90, descEN: "You made it to Burg Eisenhardt! This impressive medieval castle overlooks the town...", descDE: "Geschafft! Du hast die Burg Eisenhardt erreicht! Diese beeindruckende mittelalterliche Burg überblickt die Stadt...", isFinal: true },
        ]; // Descriptions shortened

        function initializeLandmarks() {
            landmarks = landmarkConfig.map(cfg => ({
                ...cfg,
                // Use config.groundHeight for logical positioning
                yPos: config.canvasHeight - config.groundHeight - (cfg.height || 90),
                hasBeenTriggered: false
            }));
        }
        // --- END Landmark Data ---


        // --- Player State Initialization ---
        function resetPlayer() {
            // Initial player size relative to canvas height (example)
            const playerHeight = config.canvasHeight * 0.15; // Adjust multiplier as needed
            const playerWidth = playerHeight * (60/75); // Maintain aspect ratio

            playerState = {
                x: 50, // Start position from left
                // Position player based on logical ground height
                y: config.canvasHeight - config.groundHeight - playerHeight,
                width: playerWidth,
                height: playerHeight,
                vy: 0, isGrounded: true
            };
        }


        // --- Game Reset Function ---
        function resetGame() {
            console.log("Resetting game...");
            // Ensure canvas dimensions are up-to-date before resetting player
             if (canvas.width !== config.canvasWidth || canvas.height !== config.canvasHeight) {
                 setupCanvas(); // Update canvas size if needed
             }

            resetPlayer(); // Reset player (uses current canvas dimensions)
            obstacles = [];
            initializeLandmarks(); // Reset landmarks (uses current canvas dimensions)
            score = 0;
            frameCount = 0;
            gameSpeed = config.obstacleSpeed;
            isJumpKeyDown = false;
            isPointerDownJump = false;
            playerLives = config.startLives;
            isRecovering = false;
            recoveryTimer = 0;
            backgroundX = 0;

            // Update UI
            livesDisplay.textContent = `Leben / Lives: ${playerLives}`;
            scoreDisplay.textContent = `Punkte / Score: 0`;

            // Hide overlays
            gameOverScreen.style.display = 'none';
            winScreen.style.display = 'none';
            landmarkPopup.style.display = 'none';

            // Start game
            gameState = 'running';
            requestAnimationFrame(gameLoop);
        }

        // --- Input Handling ---
        function handleJump() {
            if (gameState === 'running' && playerState.isGrounded) {
                // Adjust jump strength based on player height/gravity? Maybe later.
                playerState.vy = config.jumpStrength * (config.canvasHeight / 400); // Scale jump with canvas size?
                playerState.isGrounded = false;
            } else if (gameState === 'gameOver' && gameOverScreen.style.display !== 'none') {
                resetGame();
            } else if (gameState === 'win' && winScreen.style.display !== 'none') {
                resetGame();
            }
        }

        function hideLandmarkPopup() {
            const popupIsVisible = landmarkPopup.style.display !== 'none';
            if (!popupIsVisible) return;
            landmarkPopup.style.display = 'none';
            if (gameState === 'win') { showWinScreen(); }
            else if (gameState === 'paused') {
                gameState = 'running';
                requestAnimationFrame(gameLoop);
            }
        }

        // Event listeners
        window.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                e.preventDefault(); if (!isJumpKeyDown) { handleJump(); } isJumpKeyDown = true;
            } else if (e.key === 'Enter' || e.code === 'Enter') {
                e.preventDefault();
                if ((gameState === 'paused' || gameState === 'win') && landmarkPopup.style.display !== 'none') { hideLandmarkPopup(); }
                else if (gameState === 'gameOver' && gameOverScreen.style.display !== 'none') { resetGame(); }
                else if (gameState === 'win' && winScreen.style.display !== 'none') { resetGame(); }
            }
        });
        window.addEventListener('keyup', (e) => { if (e.code === 'Space') { e.preventDefault(); isJumpKeyDown = false; } });
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (gameState === 'running' || gameState === 'paused') { handleJump(); isPointerDownJump = true; }
            else if (gameState === 'gameOver') { resetGame(); }
            else if (gameState === 'win') { resetGame(); }
        });
        canvas.addEventListener('mousedown', (e) => { if (gameState === 'running') { handleJump(); isPointerDownJump = true; } });
        window.addEventListener('touchend', (e) => { isPointerDownJump = false; });
        window.addEventListener('mouseup', (e) => { isPointerDownJump = false; });
        gameOverScreen.addEventListener('click', resetGame);
        winScreen.addEventListener('click', resetGame);
        continueButton.addEventListener('click', hideLandmarkPopup);
        // --- END Input Handling ---


        // --- Collision Detection ---
        function checkCollision(rect1, rect2) {
            return ( rect1.x < rect2.x + rect2.width && rect1.x + rect1.width > rect2.x &&
                     rect1.y < rect2.y + rect2.height && rect1.y + rect1.height > rect2.y );
        }

        // --- Obstacle Handling ---
        const obstacleTypes = ['stoneObstacle', 'familyObstacle', 'tractorObstacle'];
        function spawnObstacle() {
            const typeIndex = Math.floor(Math.random() * obstacleTypes.length);
            const selectedTypeKey = obstacleTypes[typeIndex];

            // Scale obstacle size relative to canvas height (example scaling)
            let baseHeight, baseWidth;
            switch (selectedTypeKey) {
                case 'familyObstacle': baseHeight = 100; baseWidth = 70; break;
                case 'tractorObstacle': baseHeight = 80; baseWidth = 115; break;
                case 'stoneObstacle': default: baseHeight = 40; baseWidth = 30; break;
            }
            // Scale based on current canvas height relative to original design height (e.g., 400)
            const scaleFactor = config.canvasHeight / 400;
            let obstacleHeight = (baseHeight + Math.random() * (baseHeight * 0.3)) * scaleFactor; // Add variability
            let obstacleWidth = (baseWidth + Math.random() * (baseWidth * 0.2)) * scaleFactor;

            obstacles.push({
                x: config.canvasWidth, // Spawn off-screen right
                y: config.canvasHeight - config.groundHeight - obstacleHeight, // Position on logical ground
                width: obstacleWidth, height: obstacleHeight, typeKey: selectedTypeKey
            });
        }
        function updateObstacles() {
            // Scale spawn rate based on speed? Maybe later.
            if (frameCount > 100 && frameCount % config.spawnRate === 0) { spawnObstacle(); }
            for (let i = obstacles.length - 1; i >= 0; i--) {
                obstacles[i].x -= gameSpeed * (config.canvasWidth / 800); // Scale speed with canvas width
                if (obstacles[i].x + obstacles[i].width < 0) { obstacles.splice(i, 1); }
            }
        }
        // --- END Obstacle Handling ---


        // --- Landmark Display ---
        function showLandmarkPopup(landmark) {
            landmarkName.textContent = landmark.name;
            landmarkDescription.innerHTML = `${landmark.descEN}<br><br>${landmark.descDE}`;
            landmarkPopup.style.display = 'flex';
        }


        // --- Update Game State ---
        function update() {
            if (gameState !== 'running') return;
            frameCount++;

            if (isRecovering) { if (--recoveryTimer <= 0) { isRecovering = false; } }

            // Player physics - scale gravity?
            let currentGravity = config.gravity * (config.canvasHeight / 400);
            if (!playerState.isGrounded && playerState.vy < 0) {
                if (isJumpKeyDown || isPointerDownJump) { currentGravity *= config.jumpHoldGravityMultiplier; }
                else { currentGravity *= config.jumpCutGravityMultiplier; }
            }
            playerState.vy += currentGravity;
            playerState.y += playerState.vy;

            // Ground collision - Use logical ground height
            const groundLevel = config.canvasHeight - config.groundHeight - playerState.height;
            if (playerState.y >= groundLevel) {
                playerState.y = groundLevel; playerState.vy = 0; playerState.isGrounded = true;
            } else { playerState.isGrounded = false; }

            // Obstacles - speed scaled in updateObstacles
            updateObstacles();

            // Obstacle Collision Checks
            if (!isRecovering) {
                for (let i = obstacles.length - 1; i >= 0; i--) {
                    const obstacle = obstacles[i];
                    if (checkCollision(playerState, obstacle)) {
                        const isFalling = playerState.vy > 0;
                        const previousPlayerBottom = playerState.y + playerState.height - playerState.vy;
                        const obstacleTop = obstacle.y;
                        if (isFalling && previousPlayerBottom <= obstacleTop + 1) { // Stomp
                             // Scale stomp jump strength?
                            playerState.vy = config.stompJumpStrength * (config.canvasHeight / 400);
                            playerState.y = obstacle.y - playerState.height;
                            playerState.isGrounded = false; score += 50; obstacles.splice(i, 1); continue;
                        } else { // Hit
                             playerLives--; livesDisplay.textContent = `Leben / Lives: ${playerLives}`;
                             score -= 75; if (score < 0) { score = 0; }
                             if (playerLives <= 0) { gameState = 'gameOver'; showGameOverScreen(); return; }
                             else { isRecovering = true; recoveryTimer = config.recoveryDuration; playerState.vy = -3; playerState.isGrounded = false; break; }
                        }
                    }
                }
            }

            // Landmark Triggers - scale speed?
            const scaledGameSpeed = gameSpeed * (config.canvasWidth / 800);
            for (let landmark of landmarks) {
                landmark.worldX -= scaledGameSpeed; // Use scaled speed
                if (!landmark.hasBeenTriggered && landmark.worldX < playerState.x + playerState.width && landmark.worldX + landmark.width > playerState.x) {
                    landmark.hasBeenTriggered = true; showLandmarkPopup(landmark);
                    if (landmark.isFinal) { gameState = 'win'; } else { gameState = 'paused'; }
                    return;
                }
            }

            // Score update
            score++; scoreDisplay.textContent = `Punkte / Score: ${Math.floor(score / 5)}`;

            // Speed increase - scale max speed?
            if (frameCount > 0 && frameCount % 240 === 0) {
                const scaledMaxSpeed = config.maxGameSpeed * (config.canvasWidth / 800);
                if (gameSpeed < config.maxGameSpeed) { // Compare with base max speed
                    gameSpeed += 0.07; gameSpeed = parseFloat(gameSpeed.toFixed(2));
                }
            }

             // Background scroll - use scaled speed
             backgroundX -= scaledGameSpeed * 0.5;
             if (assets.backgroundImage && backgroundX <= -assets.backgroundImage.width) { backgroundX += assets.backgroundImage.width; }
        }


        // --- Draw Game ---
        function draw() {
            // Use current canvas dimensions
            const canvasW = config.canvasWidth;
            const canvasH = config.canvasHeight;

            ctx.clearRect(0, 0, canvasW, canvasH);

             // Draw Background
             if (assets.backgroundImage) {
                 let currentX = backgroundX % assets.backgroundImage.width;
                 if (currentX > 0) currentX -= assets.backgroundImage.width; // Ensure starting off-screen left if needed

                 // Scale background image drawing? For now, tile it.
                 while (currentX < canvasW) {
                     // Draw image to fill the area above the logical ground
                     ctx.drawImage(assets.backgroundImage, 0, 0, assets.backgroundImage.width, assets.backgroundImage.height,
                                   currentX, 0, assets.backgroundImage.width, canvasH - config.groundHeight);
                     currentX += assets.backgroundImage.width;
                 }
             } else { // Fallback
                 ctx.fillStyle = config.colors.blue;
                 ctx.fillRect(0, 0, canvasW, canvasH - config.groundHeight);
             }

             // Optional: Draw visual ground if needed (using logical height)
             ctx.fillStyle = config.colors.ground;
             ctx.fillRect(0, canvasH - config.groundHeight, canvasW, config.groundHeight);


            // Draw Player (with recovery flash)
            let drawPlayer = true;
            if (isRecovering && frameCount % 10 < 5) { drawPlayer = false; }
            if (drawPlayer) {
                if (assets.knightPlaceholder) { ctx.drawImage(assets.knightPlaceholder, playerState.x, playerState.y, playerState.width, playerState.height); }
                else { ctx.fillStyle = config.colors.green; ctx.fillRect(playerState.x, playerState.y, playerState.width, playerState.height); }
            }

            // Draw Obstacles
            obstacles.forEach(obstacle => {
                const obstacleImage = assets[obstacle.typeKey];
                if (obstacleImage) { ctx.drawImage(obstacleImage, obstacle.x, obstacle.y, obstacle.width, obstacle.height); }
                else { ctx.fillStyle = config.colors.black; ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height); }
            });

            // Draw Landmark Signs - Scale sign size?
            const signScaleFactor = config.canvasHeight / 400; // Example scaling
            landmarks.forEach(landmark => {
                if (landmark.worldX < canvasW && landmark.worldX + landmark.width > 0) { // Use current width
                    const signW = (landmark.width || 60) * signScaleFactor;
                    const signH = (landmark.height || 90) * signScaleFactor;
                     // Adjust Y position based on scaled height
                    const signY = canvasH - config.groundHeight - signH;
                    if (assets.signImage) { ctx.drawImage(assets.signImage, landmark.worldX, signY, signW, signH); }
                    else { ctx.fillStyle = config.colors.ground; ctx.fillRect(landmark.worldX, signY, signW, signH); }
                }
            });
        }
        // --- END Draw Game ---


        // --- UI Updates ---
        function showGameOverScreen() { gameOverScreen.style.display = 'flex'; }
        function showWinScreen() { winScreen.style.display = 'flex'; }


        // --- Main Game Loop ---
        function gameLoop() {
            if (gameState !== 'running') { return; }
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }


        // --- Start Game ---
        // Initial setup on load
        setupCanvas(); // Set initial canvas size
        loadAllAssets(); // Load assets, then calls resetGame()
        // --- END Start Game ---

    </script>

</body>
</html>
